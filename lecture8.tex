\section{Неразрешимость исчисления предикатов}
\subsection{Машина Тьюринга}
\begin{definition} Путь имеется бесконечная в обе стороны лента,
разделённая на ячейки, и головка "--- указатель на ячейку ленты. Помимо этого заданы $\mathcal{A}$ -
алфавит ленты, $\mathcal{S}$ "--- алфавит состояний и таблица переходов, сопоставляющая паре из символа
ленты и состояния тройку $\langle\mathcal{A}_i$,  $\mathcal{S}_j,$  $\lbrace \leftarrow, \rightarrow,
\downarrow\rbrace\rangle$. Определим три обязательных состояния: $S_0$ "--- стартовое, $S_a$ "---
допускающее и $S_r$ "--- отклоняющее. Получившуюся конструкцию назовём \textit{машиной Тьюринга}.
\end{definition}

Процесс работы машины Тьюринга следующий. Машина запускается в стартовом состоянии $S_0$, на ленте
записано входное слово. Будем считать, что все остальные ячейки содержат символ пустой строки "---
$\varepsilon$, а головка указывает на первый символ слова. Пусть текущее состояние $S_i$, а символ на
который указывает головка $\mathcal{A}_j$, тогда рассматривается соответствующая им трока
$\langle\mathcal{A}_k$,  $\mathcal{S}_p,$  $\lbrace \leftarrow, \rightarrow, \downarrow \rbrace\rangle$:
осуществляется переход в состояние $\mathcal{S}_p$, на ленте символ $\mathcal{A}_j$ заменяется на
$\mathcal{A}_k$, а головка сдвигается в соответствии с третьим аргументом тройки (влево, вправо или
остаётся на месте). Машина прекращает свою работу при попадании в состояние $S_a$ или $S_r$.

Рассмотрим некоторые примеры, демонстрирующие работу машины Тьюринга. Пусть нам дана двоичная строка, в
которой необходимо удалить незначащие нули. Для этого достаточно одного состояния: будем двигаться вправо
по слову и заменять все нули на $\varepsilon$, и как только встретим единицу, перейдём в допускающее
состояние $S_a$. Однако, исходное число могло быть равно нулю, то есть не содержать ни одной единицы, в
таком случае мы бы стёрли слово полностью, дойдя до символа $\varepsilon$. Запишем 0 заново и перейдём в
допускающее состояние.

\begin{table}[h]
    \centering
    \begin{tabular}{c c c c}
        & 0 & 1 & $\varepsilon$ \\
        
        S & 
        $\langle\varepsilon$, S, $\rightarrow\rangle$ & 
        $\langle$1, $S_a$, $\downarrow\rangle$ & 
        $\langle$0, $S_a$, $\downarrow\rangle$ \\
    \end{tabular}
    \begin{flushleft}
    \caption[Пример ]{Удаление ведущих нулей}
    \end{flushleft}
    \label{tab:my_label}
\end{table}

Другой пример. Прибавим единицу к числу в двоичной записи: с помощью состояния S перейдём к последнему
символу. Затем прибавим единицу к текущей цифре на ленте. Если это 0, заменим его на 1 и перейдём в
допускающее состояние. Если это 1, то запишем 0, и прибавим единицу (бит переноса) к числу слева. Может
так случиться, что длина числа после прибавления единицы должна увеличиться на один символ. В таком
случае машина будет находится в состоянии ADD, а головка указывать на $\varepsilon$. Заменим
$\varepsilon$ на 1 и закончим работу.

\begin{table}[h]
    \centering
    \begin{tabular}{c c c c}
        & 0 & 1 & $\varepsilon$ \\
        
        S &
        $\langle$0, S, $\rightarrow\rangle$ & 
        $\langle$1, S, $\rightarrow\rangle$ & 
        $\langle\varepsilon$, ADD, $\leftarrow\rangle$ \\
        
        ADD &
        $\langle$1, $S_a$, $\downarrow\rangle$ &
        $\langle$0, ADD, $\leftarrow\rangle$ &
        $\langle$1, $S_a$, $\downarrow\rangle$ \\
        
    \end{tabular}
    \caption{Прибавление единицы к числу на ленте}
\end{table}

\begin{definition} \textit{Разрешителем} языка $\mathcal{L}$ назовём такую машину Тьюринга $\mathcal{T}$,
которая принимает на вход слово $\phi$ и переходит в допускающее состояние, если $\phi \in \mathcal{L}$,
и в отклоняющее состояние, если $\phi \notin \mathcal{L}$.
\end{definition} 

\begin{definition} Язык $\mathcal{L}$ \textit{разрешим} если существует разрешитель этого языка.
\end{definition} 

\begin{table}[h]
    \centering
    \begin{tabular}{c c c c}
        & 0 & 1 & $\varepsilon$ \\
        
        S &
        $\langle$0, S, $\rightarrow\rangle$ & 
        $\langle$1, S, $\rightarrow\rangle$ & 
        $\langle\varepsilon$, FirstZero, $\leftarrow\rangle$ \\
        
        FirstZero &
        $\langle$0, SecondZero, $\leftarrow\rangle$ &
        $\langle$1, $S_r$, $\downarrow\rangle$ &
        $\langle\varepsilon$, $S_a$, $\downarrow\rangle$ \\
        
        SecondZero &
        $\langle$0, $S_a$, $\downarrow\rangle$ &
        $\langle$1, $S_r$, $\downarrow\rangle$ &
        $\langle\varepsilon$, $S_a$, $\downarrow\rangle$ \\
    \end{tabular}
    \caption{Проверка кратности четырём}
\end{table}

Рассмотрим пример разрешимого языка. Пусть $\mathcal{L}$ содержит все двоичные числа кратные четырём.
Построим соответсвующий разрешитель, чтобы показать его разрешимость.

Состояние FirstZero ищет первый ноль, если он обнаруживается, то делается переход в состояние SecondZero,
в противном случае слово не принимается. Сосотояние SecondZero отклоняет слово если на ленте единица,
иначе слово допускается. 

\begin{theorem} Не существует машины Тьюринга, которая по заданной машине Тьюринга $\mathcal{T}$ и
входной строке $\phi$ определит перейдёт ли $\mathcal{T}$ в допускающее состояние на входных данных
$\phi$.
\end{theorem}

\begin{proof} 
Пусть такая машина Тьюринга существует. Будем считать, что T(x, y) "--- некоторое програмное
представление такой машины и результат его работы true, если x остановиться на входе y, и false иначе.
Рассмотрим следующую программу:

\begin{verbatim}
    p(x) : 
        if (T(x, x)) while true;
        else return 1;
\end{verbatim}

Очевидно, что она зациклиться если программа х останавливается на вводе строки х, и возвращает true в
противном случае. Но что если взять код самой программы p и подать ей на вход? Пусть разрешитель T будет
считать, что p(p) остановиться и вернёт true, тогда условие в if'е выполниться и запуститься бесконечный
цикл. Наоборот, если по мнению разрешителя программа зацикливается, то он вернёт false и выполниться
строка ``return 1'' "--- программа завершиться. Получаем противоречие. Выходит, что $\mathcal{T}$ не
существует.
\end{proof}

Здесь мы сталкиваемся с одним из неразрешимых языков "--- языком программ, останавливающимися на входе
соответствующем их собственному коду. И, как видим, машина Тьюринга помогла показать его неразрешимоть.
Оказывается, что язык исчисления предикатов также является неразрешимым, докажем это, предложив алгоритм
кодирования в нём произвольной машины Тьюринга и сведя разрешимость ИП к проблеме останова.

\subsection{Теорема о неразрешимости исчисления предикатов}

Для кодирования ленты введём функциональный символ \textit{c : D $\times$ D $\rightarrow$ D}, обозначающий
конкатенацию строк. Правый аргумент это подстрока ленты, начинающаяся с символа, на который указывает
головка и до первого $\varepsilon$ включительно, а второй "--- всё, что слева от этого символа, запианное
в обратном порядке. Чтобы лучше разобраться, рассмотрим пример кодирования строки ``mathlogic'', если
головка указывает на символ `l':

\begin{center}
        с(c(`t', c(`h', c(`a', c(`m', $\varepsilon$))), 
        c(`l', c(`o', c(`g', c(`i', c(`c', $\varepsilon$)))))))
\end{center}

Введём также множество предикатных символов вида $P_k(s, t)$ "--- состояние k при ленте (s, t) достижимо,
и составим с их помощью набор правил $\pi$. Пусть в таблице переходов состоянию $S_i$ и символу
$\mathcal{A}_j$ соответствует тройка $\langle\mathcal{A}_k$,  $\mathcal{S}_r,$ $\downarrow\rangle$, тогда
добавим в $\pi$ следующее правило:

\begin{center}
    $\forall$p.$\forall$q.$P_i(p, c(\mathcal{A}_j, q))\to P_r(p, c(\mathcal{A}_k, q))$
\end{center}

Заметим, что индекс левого предикатного символа соответсвтует индексу текущего состояния, а индекс
правого соответсвует индексу состояния, в которое надо перейти. Аналогично, для символа под головкой
ленты.

Рассмотрим правила для перехода вправо. Их будет два, так как отдельно нужно обработать
выход за пределы слова:
\begin{center}
    $\forall$p.$\forall$q.$P_i(p, c(\mathcal{A}_j, q))\to P_r(c(\mathcal{A}_k, p), q)$
    
    $\forall$p.$P_i(p, \varepsilon)\to P_r(p, c(\mathcal{A}_k, \varepsilon))$
\end{center}

Аналогичным образом строятся правила для перехода влево. 

Также введём правила, кодирующие стартовое и принимающее состояния:
\begin{center}
    $\pi_0=P_0(\varepsilon$,<входная строка>)
    
    $\pi_a=\exists$p.$\exists$q.$P_a$(p, q)
\end{center}

\begin{theorem} 
    $\pi_0, \pi \vdash \pi_a \Longleftrightarrow \mathcal{T}$ завершит работу в допускающем состоянии.
\end{theorem} 
\begin{proof}
    Пусть $\mathcal{T}$ завершит свою работу в допускающем состоянии. Тогда должна сущетсвовать
    последовательность переходов ($S_0$, $\mathcal{A}_{p_0}$), ($S_i$, $\mathcal{A}_{p_1}$), ($S_j$,
    $\mathcal{A}_{p_2}$) $\ldots$, ($S_a$, $\mathcal{A}_{p_n}$). Строить доказательство будем путём
    поочерёдного добавления формул, сначала добавим в доказательство формулу $\pi_o$, характеризующую
    текущее состояние. Опишем переход к следуюущему состоянию: добавим к доказательству гипотезу
    определяющую правило соответствующего перехода. Например, если текущее состояние $S_i$, а новое
    $S_j$, и при этом происходит замена символа $\mathcal{A}_r$ на $\mathcal{A}_s$, то это будет формула
    $\forall p.\forall q.P_i(p, c(\mathcal{A}_r, q)) \rightarrow\ P_j(p, c(\mathcal{A}_s, q))$. По схеме
    аксиом 11 подставим нужные строки вместо p и q, и в конце сделаем modus ponens, получив новоее
    состояние. Таким образом мы неизбежно придём к $\pi_a$.
    
    Утверждение верно в обратную сторону в силу корретности интрепретации формул с помощью машины
    Тьюринга и того, что $\pi_0, \pi \vdash \pi_a$ влечёт $\pi_0, \pi \vDash \pi_a$
\end{proof}

\begin{theorem}
    Задача проверки доказуемости формулы в исчислении предикатов содержит частным случаем проблему
    останова $\Rightarrow$ неразрешима.
\end{theorem}
\begin{proof}
    Следует из теоремы 1.2.
\end{proof}
